#include "Shuddup.h"
#include "MAD.h"
#include "RDriver.h"
#include "RDriverInt.h"
#include "Folders.h"
#include "undo.h"
#include "QuickTimeMusic.h"
#include "Movies.h"

#include "dlsmac.h"
#include "dls.h"
#include "dls2.h"

typedef unsigned short	WORD;
typedef unsigned long	DWORD;
typedef long			FOURCC;

typedef struct{
	Str255	name;
	Str32	smpls;
	Str32	dataBits;
	Str32	stereo;
}InfoRec,*InfoPtr,**InfoHnd;

typedef struct _MMCKINFO{
	FOURCC		ckid;
	DWORD		cksize;
	FOURCC		fccType;
	DWORD		dwDataOffset;
	WORD		dwFlags;
}MMCKINFO;

typedef struct waveformat_tag{

	WORD		wFormatTag;
	WORD		nCannels;
	DWORD		nSamplesPerSec;
	DWORD		nAvgBytesPerSec;
	WORD		nBlockAlign;
	WORD		wBitsPerSample;
	
}WAVEFORMAT;

void ConvertInstrument( register	Byte	*tempPtr,	register long sSize);
void NInitSmallPiano( Rect mainRect, Rect *listRect);
void DrawSmallPianoKey( short i, short color, Rect aRect);
void NDoPlayInstru(short	Note, short Instru, short effect, short arg, short vol);
void ConvertInstrumentIn( register	Byte	*tempPtr,	register long sSize);
short OpenResFileQK( long dirID, short VRefNum);
Handle NSndToHandle( Handle sound, long *loopStart, long *loopEnd, short *sampleSize, unsigned long *sampleRate, long *baseFreq, Boolean *stereo);
void InitMapQK25();

static NoteRequest					myNoteRequest;


typedef struct _CK{
	FOURCC		ckid;
	DWORD		cksize;
}CK;

typedef struct _MyAtom{
	long		pos;
	long		id;
	long		size;
	short		ref;
}MyAtom;


/**** Resource Format ****/
typedef struct
{
	long	from;
	long	to;
	
	long	type;
	long	resID;
	long	e;
	long	f;
	
} QuictimeSs;

typedef struct
{
	char			unused[ 0x62];
	short			no;
	QuictimeSs		Ss[];
	
} QuicktimeInst;

/*************************/

/**** Resource Format QK25 ****/

typedef struct
{
	long	size;
	OSType	type;
	long	id;
	long	a[ 2];
	
	Byte	data[];
	
} QuictimeRsrc25;

/*typedef struct
{
	char			unused[ 0x70];		// 0x58
	Str31			name;
	QuictimeSs   	Ss[];
	
} QuicktimeInst25;*/

/*************************/

enum
{
	normalKey = 1,
	redKey,
	greenKey
};

		Boolean			QuicktimeInstruAvailable;
static	MenuHandle		QKInstruMenu[ 18];
static	Boolean			QK50;
static	short			QKInstruSndID[ 18][ 9];
extern	short			LastCanal;
static	short			vers1, vers2;
static	short			QK25Resources[ 500];

/*___________________ long byte swap for Intell <-> Motorola Conversions*/

unsigned long longswap(unsigned long ul)
{
	return (ul >> 24) | ((ul >> 8) & 0xff00) | ((ul << 8) & 0xff0000) | (ul << 24);
}

/*___________________ word byte swap for Intell <-> Motorola Conversions*/

unsigned short shrtswap(unsigned int us)
{
	return ((us >> 8) | (us << 8)) & 0xffff;
}

void InitQuicktimeInstruments(void)
{
	long					lS, lE, inOutBytes;
	short					sS, qQ;
	short 					i;
	short					foundVRefNum, vRefNum, iFileRef;
	long					foundDirID, dirID;
	OSErr					iErr;

	HGetVol( 0L, &vRefNum, &dirID);

	QuicktimeInstruAvailable = false;
	
	iErr = FindFolder( kOnSystemDisk, kExtensionFolderType, kDontCreateFolder, &foundVRefNum, &foundDirID);
	if( iErr == noErr)
	{
		HSetVol( 0L, foundVRefNum, foundDirID);	
		
		iFileRef = OpenResFileQK( foundDirID, foundVRefNum);
		if( iFileRef != -1)
		{
			Handle	rsrc;
			
			UseResFile( iFileRef);
			
			QuicktimeInstruAvailable = true;
			
			QK50 = false;
			rsrc = Get1Resource( 'vers', 1);
			
			vers1 = ((Byte*)*rsrc) [ 0];
			vers2 = ((Byte*)*rsrc) [ 1]>>4;
			
			if( ((Byte*)*rsrc) [ 0] >= 0x05) QK50 = true;
			ReleaseResource( rsrc);
			
			CloseResFile( iFileRef);
		}
	}
	
	QuicktimeInstruAvailable = true;
	
	{
	NoteAllocator 				na;
	
	na = OpenDefaultComponent(kNoteAllocatorComponentType,0);
	
	iErr = NAStuffToneDescription( na, 1, &myNoteRequest.tone);
	if (iErr != noErr) MyDebugStr(__LINE__, __FILE__, "NAStuff");
	
	CloseComponent( na);
	}
	
	HSetVol( 0L, vRefNum, dirID);	
}

void OctavesMIDIName(short	id, Str255	String)
{
	short			NNames[ 12] =	{'C ','C#','D ','D#','E ','F ','F#','G ','G#','A ','A#','B '};
									/*	{'Do','Do#','RŽ','RŽ#','Mi','Fa','Fa#','Sol','Sol#','La','La#','Si'};	*/
	Str255		WorkStr;
	
	if( id == 0xFF)
	{
		pStrcpy( String, "\p---");
		return;
	}
	
	NumToString( (id / 12), WorkStr);
  	String[ 1] = NNames[ (id) % 12]>>8;			String[ 2] = NNames[ (id) % 12];
	String[ 0] = 2;
  	pStrcat( String, WorkStr);	
}

void SetInstruNameM( short	theNo, Str255 theNewName, short MIDIgm, Ptr destName)
{
short	i;
Str255	aStr, bStr;

	pStrcpy( aStr, "\p(");
	NumToString( MIDIgm, bStr);
	pStrcat( aStr, bStr);
	pStrcat( aStr, "\p) ");
	pStrcat( aStr, theNewName);
	
	for(i=0; i<32; i++)
	{
		if( i < aStr[ 0]) destName[ i] = aStr[ i+1];
		else destName[ i] = '\0';
	}
	
	for( i=31; i >= 0; i--)
	{
		if( destName[ i] == 0x20 || destName[ i] == '\0') destName[ i] = '\0';
		else break;
	}
}

void SetSampNameM( Str255 theNewName, Ptr destName)
{
short	i;

	for(i=0; i<32; i++)
	{
		if( i < theNewName[ 0]) destName[i] = theNewName[i+1];
		else destName[i] = '\0';
	}
}

short OpenResFileQK( long dirID, short VRefNum)
{
	CInfoPBRec		info;
	Str255			tempStr;
	long			dirIDCopy;
	short			i, vRefNum;
	OSErr			iErr;
	FSSpec			spec;
	short			ret;
	
	pStrcpy( spec.name, "\pQuickTimeª Musical Instruments");
	spec.vRefNum = VRefNum;
	spec.parID = dirID;
	
	ret = FSpOpenResFile( &spec, fsCurPerm);
	if( ret != -1) return ret;
	
	/************/
	
	ret = -1;

	info.hFileInfo.ioNamePtr = tempStr;
	info.hFileInfo.ioVRefNum = VRefNum;
	
	for (i = 1; true; i ++)
	{
		info.hFileInfo.ioDirID = dirID;
		info.hFileInfo.ioFDirIndex = i;
		
		if (PBGetCatInfo(&info, false) != noErr) break;
		
		if( info.hFileInfo.ioFlFndrInfo.fdType == 'INIT' && info.hFileInfo.ioFlFndrInfo.fdCreator == 'dvb ')
		{	
		//	HGetVol( 0L, &vRefNum, &dirIDCopy);
			
		//	iErr = HSetVol( 0L, info.hFileInfo.ioVRefNum, dirID);
			
			pStrcpy( spec.name, info.hFileInfo.ioNamePtr);
			spec.vRefNum = info.hFileInfo.ioVRefNum;
			spec.parID = dirID;
			
			ret = FSpOpenResFile( &spec, fsCurPerm);
			
		//	iErr = HSetVol( 0L, vRefNum, dirIDCopy);
		//	if( iErr != noErr) MyDebugStr( __LINE__, __FILE__, "HSetVol error...");
		}
	}
	
	return ret;
}

short OpenDataFileQK( long dirID, short VRefNum)
{
	CInfoPBRec		info;
	Str255			tempStr;
	long			dirIDCopy;
	short			i, vRefNum;
	OSErr			iErr;
	FSSpec			spec;
	short			iRefNum = -1;
	
	info.hFileInfo.ioNamePtr = tempStr;
	info.hFileInfo.ioVRefNum = VRefNum;
	
	for (i = 1; true; i ++)
	{
		info.hFileInfo.ioDirID = dirID;
		info.hFileInfo.ioFDirIndex = i;
		
		if (PBGetCatInfo(&info, false) != noErr) break;
		
		if( info.hFileInfo.ioFlFndrInfo.fdType == 'INIT' && info.hFileInfo.ioFlFndrInfo.fdCreator == 'dvb ')
		{	
		//	HGetVol( 0L, &vRefNum, &dirIDCopy);
			
		//	iErr = HSetVol( 0L, info.hFileInfo.ioVRefNum, dirID);
			
			pStrcpy( spec.name, info.hFileInfo.ioNamePtr);
			spec.vRefNum = info.hFileInfo.ioVRefNum;
			spec.parID = dirID;
			
			iErr = FSpOpenDF( &spec, fsCurPerm, &iRefNum);
			if( iErr != noErr) iRefNum = -1;
			
		//	iErr = HSetVol( 0L, vRefNum, dirIDCopy);
		//	if( iErr != noErr) MyDebugStr( __LINE__, __FILE__, "HSetVol error...");
		}
	}
	
	return iRefNum;
}

void InitMapQK25()	// Map all samples in resources !!
{
	Handle 		hRsrc;
	Boolean		Founded = false;
	long		i, maxResources;
	short		rID;
	OSType		rType;
	Str255		rName;
	
	for( i = 0; i < 500 ; i++) QK25Resources[ i] = 0;
	
	if( !QK50) return;
	
	maxResources = CountResources( 'ssai');
	for( i = 0; i < maxResources; i++)
	{
		hRsrc = GetIndResource( 'ssai', i+1);
		if( hRsrc)
		{
			QuictimeRsrc25	*rsrc, *maxrsrc;
			
			GetResInfo( hRsrc, &rID, &rType, rName);
			
			DetachResource( hRsrc);
			HLock( hRsrc);
			if( hRsrc == 0L) MyDebugStr( __LINE__, __FILE__, "MIDI Ins Err");
			
			maxrsrc = (QuictimeRsrc25*) ((*hRsrc) + GetHandleSize( hRsrc));
			rsrc = (QuictimeRsrc25*) ((*hRsrc) + 0x20);
			
			while( rsrc < maxrsrc && rsrc->type != kaiKeyRangeInfoType) rsrc = (QuictimeRsrc25*) (((Ptr) rsrc) + rsrc->size);
			
			while( rsrc->type == kaiKeyRangeInfoType)
			{
				QuictimeRsrc25	*rsrcCopy = rsrc;
				
				rsrc = (QuictimeRsrc25*) (((Ptr) rsrc) + 5L*4L);		// go to  kaiSampleDescType
				
				if( rsrc->type == kaiSampleDescType)
				{
					InstSampleDescRec	*sdesc;
					QuictimeRsrc25		*rsrc2;
					sData				*curData;
					
					sdesc = (InstSampleDescRec*) rsrc->data;
					
					if( sdesc->dataFormat == 'raw ' || sdesc->dataFormat == 'twos')
					{
						QuictimeRsrc25		*rsrc3;
						
						Boolean	Founded = false;
						
						rsrc2 = (QuictimeRsrc25*) ((*hRsrc) + 0x20);
						while( rsrc2 < maxrsrc && (Ptr) ((Ptr) rsrc2) + rsrc2->size < (Ptr) maxrsrc && Founded == false)
						{
							rsrc2 = (QuictimeRsrc25*) (((Ptr) rsrc2) + rsrc2->size);
							
							if( rsrc2->type == kaiSampleInfoType)
							{
								rsrc3 = (QuictimeRsrc25*) (((Ptr) rsrc2) + 5L*4L);
								
								while( rsrc3->type != kaiSampleDataType) rsrc3 = (QuictimeRsrc25*) (((Ptr) rsrc3) + rsrc3->size);
								
								if( rsrc3->type == kaiSampleDataType)
								{
									if( rsrc2->id > 500) MyDebugStr( __LINE__, __FILE__, "SampleID too big !!");
									QK25Resources[ rsrc2->id] = rID;
								}
							}
						}
					}
					
				}
				
				if( (Ptr) (((Ptr) rsrcCopy) + rsrcCopy->size) < (Ptr) maxrsrc) rsrc = (QuictimeRsrc25*) (((Ptr) rsrcCopy) + rsrcCopy->size);
				else break;
			}
			
			HUnlock( hRsrc);
			DisposeHandle( hRsrc);
			
			hRsrc = 0L;
		}
	}
}

void LoadQK25Sample( long sampleID, long GMInstruID, Ptr *sample, long size)
{
// Try to load it from a previous resource !!
								
	Handle 	hRsrc;
	Boolean	Founded = false;
	
	*sample = 0L;
	
	if( QK25Resources[ sampleID] == 0) return;
	
	hRsrc = GetResource( 'ssai', QK25Resources[ sampleID]);
	if( hRsrc)
	{
		QuictimeRsrc25	*rsrc, *maxrsrc;
		
		DetachResource( hRsrc);
		HLock( hRsrc);
		if( hRsrc == 0L) MyDebugStr( __LINE__, __FILE__, "MIDI Ins Err");
		
		maxrsrc = (QuictimeRsrc25*) ((*hRsrc) + GetHandleSize( hRsrc));
		rsrc = (QuictimeRsrc25*) ((*hRsrc) + 0x20);
		
		while( rsrc < maxrsrc && rsrc->type != kaiKeyRangeInfoType) rsrc = (QuictimeRsrc25*) (((Ptr) rsrc) + rsrc->size);
		
		while( rsrc->type == kaiKeyRangeInfoType)
		{
			QuictimeRsrc25	*rsrcCopy = rsrc;
			
			rsrc = (QuictimeRsrc25*) (((Ptr) rsrc) + 5L*4L);		// go to  kaiSampleDescType
			
			if( rsrc->type == kaiSampleDescType)
			{
				InstSampleDescRec	*sdesc;
				QuictimeRsrc25		*rsrc2;
				sData				*curData;
				
				sdesc = (InstSampleDescRec*) rsrc->data;
				
				if( sdesc->sampleDataID == sampleID)
				{
					if( sdesc->dataFormat == 'raw ' || sdesc->dataFormat == 'twos')
					{
						QuictimeRsrc25		*rsrc3;
						
						Boolean	Founded = false;
						
						rsrc2 = (QuictimeRsrc25*) ((*hRsrc) + 0x20);
						while( rsrc2 < maxrsrc && Founded == false)
						{
							rsrc2 = (QuictimeRsrc25*) (((Ptr) rsrc2) + rsrc2->size);
							
							if( rsrc2->type == kaiSampleInfoType)
							{
								rsrc3 = (QuictimeRsrc25*) (((Ptr) rsrc2) + 5L*4L);
								
								while( rsrc3->type != kaiSampleDataType) rsrc3 = (QuictimeRsrc25*) (((Ptr) rsrc3) + rsrc3->size);
								
								if( rsrc3->type == kaiSampleDataType)
								{
									if( rsrc2->id  == sdesc->sampleDataID)
									{
										long inOutBytes;
										
										Founded = true;
										
										rsrc2 = rsrc3;
										
										*sample = NewPtr( size);
										
										BlockMoveData( rsrc2->data, *sample, size);
										
									/*	inOutBytes = (sdesc->sampleSize * sdesc->numSamples) / 8L;
										
										if( size != inOutBytes) MyDebugStr( __LINE__, __FILE__, "Size!!!");*/
									}
								}
							}
						}
					}
				}
			}
			
			rsrc = (QuictimeRsrc25*) (((Ptr) rsrcCopy) + rsrcCopy->size);
		}
		
		HUnlock( hRsrc);
		DisposeHandle( hRsrc);
		
		hRsrc = 0L;
	}
}

void ComputeQuicktimeSound25( short GMInstruID, sData **sample, InstrData* inst, short ins)
{
	long					lS, lE, inOutBytes;
	short					sS;
	unsigned long			sRate;
	long					bFreq;
	
	short					ii;
	short 					i, x;
	Handle					hRsrc;
	short					foundVRefNum, iFileRef;
	long					foundDirID;
	OSErr					iErr;
//	QuicktimeInst25			*QuickInst;
	Ptr						tPtr;
	Str255					aStr, bStr;
	
	/***************/
	
	for( i = 0; i < inst->numSamples; i++)
	{
		if( sample[ inst->firstSample + i] != 0L)
		{
			if( sample[ inst->firstSample + i]->data != 0L)
			{
				DisposePtr( (Ptr) sample[ inst->firstSample + i]->data);
				sample[ inst->firstSample + i]->data = 0L;
			}
			DisposePtr( (Ptr) sample[ inst->firstSample + i]);
			sample[ inst->firstSample + i] = 0L;
		}
	}
	
	for( i = 0; i < 32; i++) inst->name[ i]	= 0;
	inst->type			= 0;
	inst->numSamples	= 0;
	
	/**/
	
	for( i = 0; i < 96; i++) inst->what[ i]		= 0;
	for( i = 0; i < 12; i++)
	{
		inst->volEnv[ i].pos		= 0;
		inst->volEnv[ i].val		= 0;
	}
	for( i = 0; i < 12; i++)
	{
		inst->pannEnv[ i].pos	= 0;
		inst->pannEnv[ i].val	= 0;
	}
	inst->volSize		= 0;
	inst->pannSize		= 0;
	
	inst->volSus		= 0;
	inst->volBeg		= 0;
	inst->volEnd		= 0;
	
	inst->pannSus		= 0;
	inst->pannBeg		= 0;
	inst->pannEnd		= 0;

	inst->volType		= 0;
	inst->pannType		= 0;
	
	inst->volFade		= 900;
	inst->vibDepth		= 0;
	inst->vibRate		= 0;

	/***************/
	
	iErr = FindFolder( kOnSystemDisk, kExtensionFolderType, kDontCreateFolder, &foundVRefNum, &foundDirID);
	if( iErr == noErr)
	{
		HSetVol( 0L, foundVRefNum, foundDirID);	
		
		iFileRef = OpenResFileQK( foundDirID, foundVRefNum);
		if( iFileRef != -1)
		{
			UseResFile( iFileRef);
			
			ENCORE:
			
			while( (hRsrc = GetResource( 'ssai', GMInstruID)) == 0L) GMInstruID++;
			if( GetResourceSizeOnDisk( hRsrc) < 600) goto ENCORE;
			
			if( hRsrc != 0L)
			{
				QuictimeRsrc25	*rsrc, *maxrsrc;
				short			sampleIDMap[ 500];
				
				for( i = 0; i < 500; i++) sampleIDMap[ i] = -1;
				
				DetachResource( hRsrc);
				HLock( hRsrc);
				if( hRsrc == 0L) MyDebugStr( __LINE__, __FILE__, "MIDI Ins Err");
				
				maxrsrc = (QuictimeRsrc25*) ((*hRsrc) + GetHandleSize( hRsrc));
				
				/// NEW SYSTEM !!!!!
				
				rsrc = (QuictimeRsrc25*) ((*hRsrc) + 0x20);
				
				while( rsrc < maxrsrc && rsrc->type != kaiToneDescType) rsrc = (QuictimeRsrc25*) (((Ptr) rsrc) + rsrc->size);			// Find the name
				
				SetInstruNameM( ins, (unsigned char*) rsrc->data + 36, GMInstruID, inst->name);
				
				while( rsrc < maxrsrc && rsrc->type != kaiKeyRangeInfoType) rsrc = (QuictimeRsrc25*) (((Ptr) rsrc) + rsrc->size);
				
				while( rsrc->type == kaiKeyRangeInfoType)
				{
					QuictimeRsrc25	*rsrcCopy = rsrc;
					
					rsrc = (QuictimeRsrc25*) (((Ptr) rsrc) + 5L*4L);		// go to  kaiSampleDescType
					
					if( rsrc->type == kaiSampleDescType)
					{
						InstSampleDescRec	*sdesc;
						QuictimeRsrc25		*rsrc2;
						sData				*curData;
						Ptr					ptr2delete = 0L;
						
						sdesc = (InstSampleDescRec*) rsrc->data;
						
						// SampleData exists already ??
						
						if( sampleIDMap[ sdesc->sampleDataID] != -1)
						{
							for( ii = sdesc->pitchLow - 12; ii <= sdesc->pitchHigh - 12; ii++)
							{
								if( ii < NUMBER_NOTES && ii > 0) inst->what[ ii] = sampleIDMap[ sdesc->sampleDataID];
							}
							
							goto NEXTSAMP;
						}
						else sampleIDMap[ sdesc->sampleDataID] = inst->numSamples;
						
						for( ii = sdesc->pitchLow - 12; ii <= sdesc->pitchHigh - 12; ii++)
						{
							if( ii < NUMBER_NOTES && ii > 0) inst->what[ ii] = inst->numSamples;
						}
						
						if( sdesc->offset != 0) MyDebugStr( __LINE__, __FILE__, "Offset!");
						
						// Go to DATA
						
						if( sdesc->dataFormat == 'raw ' || sdesc->dataFormat == 'twos')
						{
							QuictimeRsrc25		*rsrc3;
							
							Boolean	Founded = false;
							
							rsrc2 = (QuictimeRsrc25*) ((*hRsrc) + 0x20);
							while( rsrc2 < maxrsrc && Founded == false)
							{
								rsrc2 = (QuictimeRsrc25*) (((Ptr) rsrc2) + rsrc2->size);
								
								if( rsrc2->type == kaiSampleInfoType)
								{
									rsrc3 = (QuictimeRsrc25*) (((Ptr) rsrc2) + 5L*4L);
									
									while( rsrc3->type != kaiSampleDataType) rsrc3 = (QuictimeRsrc25*) (((Ptr) rsrc3) + rsrc3->size);
									
									if( rsrc3->type == kaiSampleDataType)
									{
										if( rsrc2->id  == sdesc->sampleDataID)
										{
											Founded = true;
										}
									}
								}
							}
							
							if( Founded)
							{
								ptr2delete = 0L;
								rsrc2 = rsrc3;			// go to  
								inOutBytes = (sdesc->sampleSize * sdesc->numSamples) / 8L;
							}
							else
							{
								inOutBytes = (sdesc->sampleSize * sdesc->numSamples) / 8L;
								
								LoadQK25Sample( sdesc->sampleDataID, GMInstruID, &ptr2delete, inOutBytes);
								
								if( !ptr2delete) inOutBytes = 0L;
								else Founded = true;
							}
						}
						else inOutBytes = 0;
						
						// ************************
						// * Add it to instrument *
						// ************************
						
						{
							if( curMusic != 0L) curData = MADCreateSample( curMusic, ins, inst->numSamples);
							else
							{
								curData = (sData*) NewPtrClear( sizeof( sData));
								if( curData == 0L) MyDebugStr( __LINE__, __FILE__, "");
								sample[ ins * MAXSAMPLE + inst->numSamples] = curData;
								
								inst->numSamples++;
							}
							
							curData->size		= 0L;
							curData->loopBeg	= 0L;
							curData->loopSize	= 0L;
							curData->vol		= MAX_VOLUME;
							curData->c2spd		= NOFINETUNE;
							curData->loopType	= eClassicLoop;
							curData->amp		= 8;
							curData->relNote	= 0;
							// curData->name
							
							curData->data = NewPtr( inOutBytes);
							
							if( curData->data == 0L)
							{
								Erreur( 63, -2);
								
								curData->size = 0L;
							}
							else
							{
								if( inOutBytes)
								{
									if( !ptr2delete) BlockMoveData( rsrc2->data, curData->data, inOutBytes);
									else
									{
										BlockMoveData( ptr2delete, curData->data, inOutBytes);
										DisposePtr( ptr2delete);
										ptr2delete = 0L;
									}
								}
								
								if( sdesc->dataFormat == 'raw ')
								{
									switch( sdesc->sampleSize)
									{
										case 8:
											ConvertInstrumentIn( (Byte*) curData->data, inOutBytes);
										break;
										
									/*	case 16:
											ConvertInstrumentIn16( (short*) curData->data, inOutBytes);
										break;*/
									}
								}
								curData->size 		= inOutBytes;
								curData->loopBeg 	= sdesc->loopStart;
								curData->loopSize 	= sdesc->loopEnd - sdesc->loopStart;
								curData->vol 		= 64;
								curData->amp	 	= sdesc->sampleSize;
								
								if( sdesc->numChannels == 2)
								{
									curData->stereo = true;
								}
								if( sdesc->numChannels > 2) MyDebugStr( __LINE__, __FILE__, "More than 2 channels");
								
								// **
								curData->c2spd		= sdesc->sampleRate >> 16;
								curData->relNote	= 60 - sdesc->pitchNormal;
								// **
								
								OctavesMIDIName( sdesc->pitchLow - 12, aStr);
								pStrcat( aStr, "\p -> ");
								OctavesMIDIName( sdesc->pitchHigh - 12, bStr);
								pStrcat( aStr, bStr);
								pStrcat( aStr, "\p, ");
								NumToString( curData->c2spd, bStr);
								pStrcat( aStr, bStr);
								pStrcat( aStr, "\p Hz");
								
								SetSampNameM( aStr, curData->name);
							}
						}
						// ************************
					}
				//	else MyDebugStr( __LINE__, __FILE__, "");
					
					NEXTSAMP:
					
					rsrc = (QuictimeRsrc25*) (((Ptr) rsrcCopy) + rsrcCopy->size);
				}
				
				HUnlock( hRsrc);
				DisposeHandle( hRsrc);
			}
			CloseResFile( iFileRef);
		}
	//	else Erreur( 72, iFileRef);
	}
	else Erreur( 72, 0);
	
//	SetCursor( GetQDGlobalsArrow( &qdarrow));
}


void ComputeQuicktimeSound( short GMInstruID, sData **sample, InstrData* inst, short ins)
{
	long					lS, lE, inOutBytes;
	short					sS;
	unsigned long			sRate;
	long					bFreq;
	
	short					ii;
	short 					i, x;
	Handle					HSnd, hRsrc;
	short					foundVRefNum, iFileRef;
	long					foundDirID;
	OSErr					iErr;
	QuicktimeInst			*QuickInst;
	Ptr						tPtr;
	Str255					aStr, bStr;
	Boolean					stereo;
		
	/***************/
	
	if( QK50) { ComputeQuicktimeSound25( GMInstruID, sample, inst, ins); return;}
	
	for( i = 0; i < inst->numSamples; i++)
	{
		if( sample[ inst->firstSample + i] != 0L)
		{
			if( sample[ inst->firstSample + i]->data != 0L)
			{
				DisposePtr( (Ptr) sample[ inst->firstSample + i]->data);
				sample[ inst->firstSample + i]->data = 0L;
			}
			DisposePtr( (Ptr) sample[ inst->firstSample + i]);
			sample[ inst->firstSample + i] = 0L;
		}
	}
	
	for( i = 0; i < 32; i++) inst->name[ i]	= 0;
	inst->type			= 0;
	inst->numSamples	= 0;
	
	/**/
	
	for( i = 0; i < 96; i++) inst->what[ i]		= 0;
	for( i = 0; i < 12; i++)
	{
		inst->volEnv[ i].pos		= 0;
		inst->volEnv[ i].val		= 0;
	}
	for( i = 0; i < 12; i++)
	{
		inst->pannEnv[ i].pos	= 0;
		inst->pannEnv[ i].val	= 0;
	}
	inst->volSize		= 0;
	inst->pannSize		= 0;
	
	inst->volSus		= 0;
	inst->volBeg		= 0;
	inst->volEnd		= 0;
	
	inst->pannSus		= 0;
	inst->pannBeg		= 0;
	inst->pannEnd		= 0;

	inst->volType		= 0;
	inst->pannType		= 0;
	
	inst->volFade		= 900;
	inst->vibDepth		= 0;
	inst->vibRate		= 0;

	/***************/
	
	iErr = FindFolder( kOnSystemDisk, kExtensionFolderType, kDontCreateFolder, &foundVRefNum, &foundDirID);
	if( iErr == noErr)
	{
		HSetVol( 0L, foundVRefNum, foundDirID);	
		
		iFileRef = OpenResFileQK( foundDirID, foundVRefNum);
		if( iFileRef != -1)
		{
			UseResFile( iFileRef);
			
			while( (hRsrc = GetResource( 'INST', GMInstruID)) == 0L) GMInstruID++;
			
			if( hRsrc != 0L)
			{
				DetachResource( hRsrc);
				HLock( hRsrc);
				if( hRsrc == 0L) MyDebugStr( __LINE__, __FILE__, "MIDI Ins Err");
				QuickInst = (QuicktimeInst*) *hRsrc;
				
				tPtr = (Ptr) (((Ptr) &QuickInst->no) + 4L + QuickInst->no * sizeof( QuictimeSs));
				SetInstruNameM( ins, (unsigned char*) tPtr, GMInstruID, inst->name);
				
				for( i = 0; i < QuickInst->no; i++)
				{
					sData	*curData;
									
					if( QuickInst->Ss[ i].type > 0)
					{
						for( ii = QuickInst->Ss[ i].from - 12; ii <= QuickInst->Ss[ i].to - 12; ii++)
						{
							if( ii < NUMBER_NOTES && ii > 0) inst->what[ ii] = inst->numSamples;
						}
					}
					
					HSnd = Get1Resource( 'snd ', QuickInst->Ss[ i].resID);
					if( HSnd != 0L)
					{
						DetachResource( HSnd);
						
						HSnd =  NSndToHandle( HSnd, &lS, &lE, &sS, &sRate, &bFreq, &stereo);
						
						inOutBytes = GetHandleSize( HSnd);
						if( sS == 8) ConvertInstrumentIn( (Byte*) *HSnd, inOutBytes);
					//	else ConvertInstrumentIn16( (short*) *HSnd, inOutBytes);
						
						/************************/
						/* Add it to instrument */
						/************************/
						
						if( curMusic != 0L) curData = MADCreateSample( curMusic, ins, inst->numSamples);
						else
						{
							curData = (sData*) NewPtrClear( sizeof( sData));
							
							sample[ ins * MAXSAMPLE + inst->numSamples] = curData;
							
							inst->numSamples++;
						}
						
						curData->size		= 0L;
						curData->loopBeg	= 0L;
						curData->loopSize	= 0L;
						curData->vol		= MAX_VOLUME;
						curData->c2spd		= NOFINETUNE;
						curData->loopType	= eClassicLoop;
						curData->amp		= 8;
						curData->relNote	= 0;
						// curData->name
						
					
						curData->data = NewPtrClear( inOutBytes);
						
						if( curData->data == 0L)
						{
							Erreur( 63, -2);
							HUnlock( HSnd);
							DisposeHandle( HSnd);
							
							curData->size = 0L;
						}
						else
						{
							BlockMoveData( *HSnd, curData->data, inOutBytes);
							
							HUnlock( HSnd);
							DisposeHandle( HSnd);
							
							curData->size 		= inOutBytes;
							curData->loopBeg 	= lS;
							curData->loopSize 	= lE - lS;
							curData->vol 		= 64;
							curData->amp	 	= sS;
							curData->stereo		= stereo;
							
							/**/
							curData->c2spd		= sRate >> 16;
							curData->relNote	= 60 - bFreq;		//QuickInst->Ss[ i].resID - (GMInstruID*100);
							/**/
							
							OctavesMIDIName( QuickInst->Ss[ i].from - 12, aStr);
							pStrcat( aStr, "\p -> ");
							OctavesMIDIName( QuickInst->Ss[ i].to - 12, bStr);
							pStrcat( aStr, bStr);
							pStrcat( aStr, "\p, ");
							NumToString( curData->c2spd, bStr);
							pStrcat( aStr, bStr);
							pStrcat( aStr, "\p Hz");
							
							SetSampNameM( aStr, curData->name);
						}
					//	inst->numSamples++;
						/************************/
					}
				}
				HUnlock( hRsrc);
				DisposeHandle( hRsrc);
			}
			CloseResFile( iFileRef);
		}
	//	else Erreur( 72, iFileRef);
	}
	else Erreur( 72, 0);
}

OSErr CreateNameListQuicktime25(void)
{
	OSErr					iErr;
	short					foundVRefNum, iFileRef, i, x, GM, z;
	long					foundDirID;
	Handle					hRsrc;
//	QuicktimeInst25			*QuickInst;
	Ptr						tPtr;

	iErr = FindFolder( kOnSystemDisk, kExtensionFolderType, kDontCreateFolder, &foundVRefNum, &foundDirID);
	
	if( iErr == noErr)
	{
		HSetVol( 0L, foundVRefNum, foundDirID);	
		
		iFileRef = OpenResFileQK( foundDirID, foundVRefNum);
		if( iFileRef != -1)
		{
			UseResFile( iFileRef);
			
			x = 0;
			GM = 1;
			for( i = 1; i <= 128; i++)
			{
				if( ((i-1) % 8) == 0)
				{
					x++;
					QKInstruMenu[ x] = NewMenu( x, "\p");
					
					GM = 1;
				}
				
				hRsrc = GetResource( 'ssai', i);
				if( hRsrc != 0L)
				{
					DetachResource( hRsrc);
					HLock( hRsrc);
					
					if( GetHandleSize( hRsrc) > 600)
					{
						QuictimeRsrc25	*rsrc, *maxrsrc = (QuictimeRsrc25*) ((*hRsrc) + GetHandleSize( hRsrc));
						
						rsrc = (QuictimeRsrc25*) ((*hRsrc) + 0x20);
						
						while( rsrc < maxrsrc && rsrc->type != kaiToneDescType) rsrc = (QuictimeRsrc25*) (((Ptr) rsrc) + rsrc->size);			// Find the name
						
						tPtr = (Ptr) rsrc->data + 36;
						
						for( z = 1; z <= tPtr[ 0]; z++)
						{
							if( tPtr[ z] == '(') tPtr[ z] = ' ';
							if( tPtr[ z] == ')') tPtr[ z] = ' ';
						}
						
						AppendMenu( QKInstruMenu[ x], (unsigned char*) tPtr);
						QKInstruSndID[ x][ GM] = i;
						GM++;
					}
					HUnlock( hRsrc);
					DisposeHandle( hRsrc);
				}
			}
			
			/** Drums **/
			
			hRsrc = GetResource( 'ssai', 16385);
			if( hRsrc != 0L)
			{
				QuictimeRsrc25	*rsrc, *maxrsrc = (QuictimeRsrc25*) ((*hRsrc) + GetHandleSize( hRsrc));
				
				rsrc = (QuictimeRsrc25*) ((*hRsrc) + 0x20);
				
				while( rsrc < maxrsrc && rsrc->type != kaiToneDescType) rsrc = (QuictimeRsrc25*) (((Ptr) rsrc) + rsrc->size);			// Find the name
				
				tPtr = (Ptr) rsrc->data + 36;
				
				for( z = 1; z <= tPtr[ 0]; z++)
				{
					if( tPtr[ z] == '(') tPtr[ z] = ' ';
					if( tPtr[ z] == ')') tPtr[ z] = ' ';
				}
				
				x++;
				QKInstruMenu[ x] = NewMenu( x, "\p");
				AppendMenu( QKInstruMenu[ x], (unsigned char*) tPtr);
				QKInstruSndID[ x][ 1] = 16385;
				
				ReleaseResource( hRsrc);
			}
			
		//	InitMapQK25();
			
			CloseResFile( iFileRef);
		}
		else {	Erreur( 72, iFileRef);	return -1;}
	}
	else {	Erreur( 72, -1);	return -1;}
	
	return noErr;
}

OSErr CreateNameListQuicktime(void)
{
	OSErr					iErr;
	short					foundVRefNum, iFileRef, i, x, GM, z;
	long					foundDirID;
	Handle					hRsrc;
	QuicktimeInst			*QuickInst;
	Ptr						tPtr;
	
	if( QK50) return CreateNameListQuicktime25();
	
	iErr = FindFolder( kOnSystemDisk, kExtensionFolderType, kDontCreateFolder, &foundVRefNum, &foundDirID);
	
	if( iErr == noErr)
	{
		HSetVol( 0L, foundVRefNum, foundDirID);	
		
		iFileRef = OpenResFileQK( foundDirID, foundVRefNum);
		if( iFileRef != -1)
		{
			UseResFile( iFileRef);
			
			x = 0;
			GM = 1;
			for( i = 1; i <= 128; i++)
			{
				if( ((i-1) % 8) == 0)
				{
					x++;
					QKInstruMenu[ x] = NewMenu( x, "\p");
					
					GM = 1;
				}
				
				hRsrc = GetResource( 'INST', i);
				if( hRsrc != 0L)
				{
					QuickInst = (QuicktimeInst*) *hRsrc;
					tPtr = (Ptr) (((Ptr) &QuickInst->no) + 4L + QuickInst->no * sizeof( QuictimeSs));
					
					for( z = 1; z <= tPtr[ 0]; z++)
					{
						if( tPtr[ z] == '(') tPtr[ z] = ' ';
						if( tPtr[ z] == ')') tPtr[ z] = ' ';
					}
					
					AppendMenu( QKInstruMenu[ x], (unsigned char*) tPtr);
					QKInstruSndID[ x][ GM] = i;
					GM++;
					
					ReleaseResource( hRsrc);
				}
			}
			
			/** Drums **/
			
			hRsrc = GetResource( 'INST', 16385);
			if( hRsrc != 0L)
			{
				QuickInst = (QuicktimeInst*) *hRsrc;
				tPtr = (Ptr) (((Ptr) &QuickInst->no) + 4L + QuickInst->no * sizeof( QuictimeSs));
				
				for( z = 1; z <= tPtr[ 0]; z++)
				{
					if( tPtr[ z] == '(') tPtr[ z] = ' ';
					if( tPtr[ z] == ')') tPtr[ z] = ' ';
				}
				
				x++;
				QKInstruMenu[ x] = NewMenu( x, "\p");
				AppendMenu( QKInstruMenu[ x], (unsigned char*) tPtr);
				QKInstruSndID[ x][ 1] = 16393;
				
				ReleaseResource( hRsrc);
			}
			
			CloseResFile( iFileRef);
		}
		else {	Erreur( 72, iFileRef);	return -1;}
	}
	else {	Erreur( 72, -1);	return -1;}
	
	return noErr;
}

static	Rect	SPianoRect[ NUMBER_NOTES];
static	short	curSPos;

void UpdateQKInstruWindow( DialogPtr theDia)
{
GrafPtr	savePort;

	GetPort( &savePort);
	SetPortDialogPort( theDia);
	
	BeginUpdate( GetDialogWindow( theDia));
	
		DrawDialog( theDia);
		oldFrameButton( theDia);
		
		DrawSmallPianoKey( curSPos, greenKey, SPianoRect[ curSPos]);
		
	EndUpdate( GetDialogWindow( theDia));
	SetPort( savePort);
}

void PressSmallPianoQ( DialogPtr TheDia, InstrData	*inst, short ins)
{
	Point	Mouse;
	Handle	itemHandle;
	short	Position, itemType, i;
	Str255	str;
	Rect	itemRect;
	long	newSize;
	Boolean	firstTime = true;
	
	do
	{
		DoGlobalNull();
		
		GetMouse( &Mouse);
		
		Position = -1;
		for( i = 0; i < NUMBER_NOTES; i++)
		{
			if( PtInRect( Mouse, &SPianoRect[ i]))
			{
				Position = i;
				if( SPianoRect[ i].right - SPianoRect[ i].left == 5) goto OK;
			}
		}
		
		if( Position >= 0)
		{
			OK:
			if( Position != curSPos)
			{
				if( curSPos != -1) DrawSmallPianoKey( curSPos, normalKey, SPianoRect[ curSPos]);
				DrawSmallPianoKey( Position, greenKey, SPianoRect[ Position]);
				curSPos = Position;
				
				MADDriver->chan[ LastCanal].KeyOn = false;
				NDoPlayInstru( curSPos, ins, 0, 0, 0xFF);
				
				str[ 0] = 3;
				str[ 1] = ENote[ curSPos][ 0];
				str[ 2] = ENote[ curSPos][ 1];
				str[ 3] = ENote[ curSPos][ 2];
				
				SetDText( TheDia, 10, str);
				
				firstTime = false;
			}
			else
			{
				if( firstTime)
				{
					firstTime = false;
					NDoPlayInstru( curSPos, ins, 0, 0, 0xFF);
				}
			}
		}
	}while( Button());
	
	MADDriver->chan[ LastCanal].KeyOn = false;
}

void ComputeInstSize( Str255	aStr, InstrData *inst, short ins)
{
long	tot = 0L;
long	i;

	for( i = 0; i < inst->numSamples; i++)
	{
		if( curMusic->sample[ inst->firstSample + i] == 0L) MyDebugStr( __LINE__, __FILE__, "Inst Error");
		
		tot += curMusic->sample[ inst->firstSample +  i]->size;
	}

	NumToString( tot, aStr);
	pStrcat( aStr, "\p bytes");
}

void ReadList( short iFileRef, long listType, long listSize)
{
long 	prePos, fSize, ilistType, nlistType;
CK		sck;
OSErr	iErr;

listSize -= 4;

do
{
	fSize = sizeof( sck);
	iErr = FSRead( iFileRef, &fSize, &sck);
	if( iErr) Debugger();
	sck.cksize = longswap( sck.cksize);

	GetFPos( iFileRef, &prePos);
	
	listSize -= sizeof( sck);
	
	switch( sck.ckid)
	{
		case 'LIST':
		
			fSize = 4;
			iErr = FSRead( iFileRef, &fSize, &ilistType);
			
			ReadList( iFileRef, ilistType, sck.cksize);
		break;
	}
	
	iErr = SetFPos( iFileRef, fsFromStart, prePos + sck.cksize);
	if( iErr) Debugger();
	
	listSize -= sck.cksize;

	listSize /= 2;
	listSize *= 2;

}while( iErr == noErr && listSize > 0);

if( listSize < 0 ) Debugger();
}

OSErr GetAtomData( MyAtom at, void* data, long size)
{
long 	prePos, fSize, ilistType, nlistType, index, listSize;
CK		sck;
OSErr	iErr;
MyAtom	retat;

iErr = SetFPos( at.ref, fsFromStart, at.pos -4);

fSize = sizeof( sck);
iErr = FSRead( at.ref, &fSize, &sck);
if( iErr) Debugger();
sck.cksize = longswap( sck.cksize);

//if( sck.cksize > size) Debugger();

fSize = size;	//sck.cksize;
iErr = FSRead( at.ref, &fSize, data);
if( iErr) Debugger();

return noErr;
}

void DebugLong( long type)
{
	Str31	str;
	
	str[ 0] = 4;
	BlockMoveData( &type, &str[ 1], 4);
	
	DebugStr( str);
}

OSErr GetAtomString(MyAtom sat4, Ptr text)
{
long	fSize = sat4.size;
OSErr	iErr;

iErr = SetFPos( sat4.ref, fsFromStart, sat4.pos + 4);	// + 4 pourquoi? Paske y a la taille de la string

iErr = FSRead( sat4.ref, &fSize, text);

return iErr;
}

long CountAtomById( MyAtom at, long type)
{
long 	prePos, fSize, ilistType, nlistType, index, listSize;
CK		sck;
OSErr	iErr;

listSize = at.size;

listSize -= 4;
index = 0;

iErr = SetFPos( at.ref, fsFromStart, at.pos);

do
{
	fSize = sizeof( sck);
	iErr = FSRead( at.ref, &fSize, &sck);
	if( iErr) DebugLong( iErr);
	sck.cksize = longswap( sck.cksize);

	GetFPos( at.ref, &prePos);
	
	listSize -= sizeof( sck);
	
	if( sck.ckid == type) index++;
	
	switch( sck.ckid)
	{
		case 'LIST':
		
			fSize = 4;
			iErr = FSRead( at.ref, &fSize, &ilistType);
			
			if( ilistType == type) index++;
		break;
	}
	
	iErr = SetFPos( at.ref, fsFromStart, prePos + sck.cksize);
	if( iErr) DebugLong( iErr);
	
	listSize -= sck.cksize;

	listSize /= 2;
	listSize *= 2;

}while( iErr == noErr && listSize > 0);

if( listSize < 0 ) Debugger();

return index;
}

OSErr FindAtomById( MyAtom at, MyAtom *retat, Boolean LIST, long type, short id)
{
long 	prePos, fSize, ilistType, nlistType, index, listSize;
CK		sck;
OSErr	iErr;

listSize = at.size;

listSize -= 4;
index = 0;

iErr = SetFPos( at.ref, fsFromStart, at.pos);

do
{
	fSize = sizeof( sck);
	iErr = FSRead( at.ref, &fSize, &sck);
	if( iErr) DebugLong( iErr);
	sck.cksize = longswap( sck.cksize);

	GetFPos( at.ref, &prePos);
	
	listSize -= sizeof( sck);
	
	if( sck.ckid == type)
	{
		if( index == id)
		{
			// We found it !!!!!
			retat->pos = prePos -4;
			retat->id = sck.ckid;
			retat->size = sck.cksize;
			retat->ref = at.ref;
			
			return noErr;
		}
		index++;
	}
	
	switch( sck.ckid)
	{
		case 'LIST':
	//	case 'INFO':
			fSize = 4;
			iErr = FSRead( at.ref, &fSize, &ilistType);
			
			if( ilistType == type)
			{
				if( index == id)
				{
					GetFPos( at.ref, &prePos);
					
					// We found it !!!!!
					retat->pos = prePos;
					retat->id = ilistType;
					retat->size = sck.cksize;
					retat->ref = at.ref;
					
					return noErr;
				}
				index++;
			}
		break;
	}
	
	iErr = SetFPos( at.ref, fsFromStart, prePos + sck.cksize);
	if( iErr) DebugLong( iErr);
	
	listSize -= sck.cksize;

	listSize /= 2;
	listSize *= 2;

}while( iErr == noErr && listSize > 0);

if( listSize < 0 ) Debugger();

return -1;
}

OSErr GetAtomDataById( MyAtom at, long type, void *data, long size)
{
	MyAtom 	tempAt;
	OSErr	iErr;

	iErr = FindAtomById( at, &tempAt, true, type, 0);
	if( iErr) return( iErr);


	iErr = GetAtomData( tempAt, data, size);
	if( iErr) return( iErr);

return noErr;
}

void Quicktime5()
{
	short 						synthCount, foundVRefNum, iFileRef, no, ii, i;
	OSErr 						thisError;
	NoteAllocator 				na;
	NoteChannel					nc;
	Handle						result;
	OSType						synthType;
	Str31						synthName;
	AtomicInstrument			ai;
	SynthesizerDescription		sd;
	MusicComponent 				mc;

	Str255						aStr, bStr;
	
	sData						*curData;
	long						size, inOutBytes, foundDirID;
	Ptr							data;
	QTAtom						myKeyRangeInfoAtom = 0;
	QTAtom						mySampleInfoAtom = 0;
	QTAtom						mySampleDescAtom = 0;
	QTAtom						mySampleDataAtom = 0;
	QTAtom						myInstInfoAtom = 0;
	QTAtom						myToneDescAtom = 0;
	QTAtom						myInstrumentRefAtom = 0;
	QTAtomID					atomID;
	
	short						ins, samp, x;
	
	sData						**sample;
	InstrData					*inst;
	
	short						sampleIDMap[ 500];
	

	for( i = 0; i < 500; i++) sampleIDMap[ i] = -1;
	
	if( !GetIns( &ins, &samp))
	{
		Erreur( 13, ins);
		return;
	}
	
	na = OpenDefaultComponent(kNoteAllocatorComponentType,0);

	synthCount = NAGetRegisteredMusicDevice( na, 0, nil, nil, nil, nil);

	while( synthCount)
	{
		thisError = NAGetRegisteredMusicDevice(na,synthCount, &synthType, synthName, nil, &mc);
		
		if(!synthName[0])
		{
			SynthesizerDescription sd;

			MusicGetDescription( mc, &sd);
			BlockMove( sd.name, synthName, sd.name[0]+1);
		}
		
		if( synthType == kSoftSynthComponentSubType) goto PROCESS;
		
		synthCount--;
	}
	
	goto BAIL;
	
	PROCESS:
	
	// fill out a note request, using NAStuffToneDescription
	myNoteRequest.info.flags = 0;
	myNoteRequest.info.reserved = 0;
	*(short *)(&myNoteRequest.info.polyphony) = EndianS16_NtoB(2);				// simultaneous tones
	*(Fixed *)(&myNoteRequest.info.typicalPolyphony) = EndianU32_NtoB(0x00010000);
	
	thisError = NAStuffToneDescription( na, myNoteRequest.tone.instrumentNumber, &myNoteRequest.tone);
	if (thisError != noErr) MyDebugStr(__LINE__, __FILE__, "NAStuff");
	
	myNoteRequest.tone.synthesizerType = synthType;
	pStrcpy( myNoteRequest.tone.synthesizerName, synthName);
	
	// display the instrument picker dialog box to elicit an instrument from the user
	thisError = NAPickInstrument( na, 0L, "\pPick an instrument:", &myNoteRequest.tone, kPickSameSynth + kPickUserInsts, 0, 0, 0);
	if (thisError != noErr) goto BAIL;
	
	SaveUndo( USample, ins, "\pUndo 'Create MIDI instrument'");
	
	sample = curMusic->sample;
	inst = &curMusic->fid[ ins];
	
	for( i = 0; i < inst->numSamples; i++)
	{
		if( sample[ inst->firstSample + i] != 0L)
		{
			if( sample[ inst->firstSample + i]->data != 0L)
			{
				DisposePtr( (Ptr) sample[ inst->firstSample + i]->data);
				sample[ inst->firstSample + i]->data = 0L;
			}
			DisposePtr( (Ptr) sample[ inst->firstSample + i]);
			sample[ inst->firstSample + i] = 0L;
		}
	}
	
	for( i = 0; i < 32; i++) inst->name[ i]	= 0;
	inst->type			= 0;
	inst->numSamples	= 0;
	
	/**/
	
	for( i = 0; i < 96; i++) inst->what[ i]		= 0;
	for( i = 0; i < 12; i++)
	{
		inst->volEnv[ i].pos		= 0;
		inst->volEnv[ i].val		= 0;
	}
	for( i = 0; i < 12; i++)
	{
		inst->pannEnv[ i].pos	= 0;
		inst->pannEnv[ i].val	= 0;
	}
	inst->volSize		= 0;
	inst->pannSize		= 0;
	
	inst->volSus		= 0;
	inst->volBeg		= 0;
	inst->volEnd		= 0;
	
	inst->pannSus		= 0;
	inst->pannBeg		= 0;
	inst->pannEnd		= 0;

	inst->volType		= 0;
	inst->pannType		= 0;
	
	inst->volFade		= 900;
	inst->vibDepth		= 0;
	inst->vibRate		= 0;

	/***************/
	
// CHECK THIS	myNoteRequest.tone
	
	thisError = MusicSetPartInstrumentNumber(mc, 1, myNoteRequest.tone.instrumentNumber);
	if( thisError) goto BAIL;
	
	thisError = MusicGetPartAtomicInstrument(mc, 1, &ai, 0);
	if( thisError) goto BAIL;
	
/*	thisError = NANewNoteChannel( na, &myNoteRequest, &nc);
	if( thisError) Debugger();
	
	thisError = NAPickEditInstrument( na, 0L, "\pTest", 0, nc, ai, 0);
	if( thisError) Debugger();
	
	NADisposeNoteChannel( na, nc);
	
	QTAtomType Atomtype = 0;
	do
	{
		Atomtype = QTGetNextChildType( ai, kParentAtomIsContainer, Atomtype);
		
		Debugger();
	}
	while( Atomtype != 0);*/
	
	OSErr		iErr;
	long		fSize, tot;
	Ptr			CWAVERsrc, WAVERsrc;
	MMCKINFO	mm;
	CK			ck;
	long		listType, noIns;
	MyAtom		at, sat, insAt, insHe, rgnAt, sat3, sat4, InfoAt, InfoData;
	Str31		str;
	Str255		text;
	char		insName[ 255];
	INSTHEADER 	curIns;
				
	iErr = FindFolder( kOnSystemDisk, kExtensionFolderType, kDontCreateFolder, &foundVRefNum, &foundDirID);
	if( iErr == noErr)
	{
		HSetVol( 0L, foundVRefNum, foundDirID);	
		
		iFileRef = OpenDataFileQK( foundDirID, foundVRefNum);
		if( iFileRef != -1)
		{
			// RIFF ID
			fSize = sizeof( ck);
			iErr = FSRead( iFileRef, &fSize, &ck);
			ck.cksize = longswap( ck.cksize);
			
			if( ck.ckid != 'RIFF') Debugger();
			
			fSize = 4;
			iErr = FSRead( iFileRef, &fSize, &listType);
			
			
			
			GetFPos( iFileRef, &at.pos);
			at.id = listType;
			at.ref = iFileRef;
			at.size = ck.cksize;
			
			iErr = FindAtomById( at, &sat, true, 'colh', 0);
			if( iErr) DebugLong( iErr);
			
			iErr = GetAtomData( sat, &noIns, sizeof( long));
			if( iErr) DebugLong( iErr);
			noIns = longswap( noIns);
			
			
			iErr = FindAtomById( at, &sat, true, 'lins', 0);
			if( iErr) DebugLong( iErr);
			
			tot = CountAtomById( sat, 'ins ');
			for( i = 0 ; i < tot; i++)
			{
				iErr = FindAtomById( sat, &insAt, true, 'ins ', i);
				if( iErr) DebugLong( iErr);
				
				iErr = FindAtomById( insAt, &insHe, true, 'insh', 0);
				if( iErr) DebugLong( iErr);
				
				iErr = GetAtomData( insHe, &curIns, sizeof( curIns));
				if( iErr) DebugLong( iErr);
				
				curIns.cRegions = longswap( curIns.cRegions);
				curIns.Locale.ulBank = longswap( curIns.Locale.ulBank);
				curIns.Locale.ulInstrument = longswap( curIns.Locale.ulInstrument);
				
			/*	iErr = FindAtomById( insAt, &InfoAt, true, 'INFO', 0);
				if( iErr) DebugLong( iErr);
				
				iErr = FindAtomById( InfoAt, &InfoData, true, 'INAM', 0);
				if( iErr) DebugLong( iErr);
				
				iErr = GetAtomData( InfoData, insName, sizeof( insName));*/
				
				if( myNoteRequest.tone.instrumentNumber >= 16384) // DRUM KIT
				{
					if( BitTst( &curIns.Locale.ulBank, 31-31))
					{
						long	valeurQT, gmID, valeurBank;
						
						gmID = myNoteRequest.tone.instrumentNumber;
						gmID = gmID & 0x000000FF;
						
						if( gmID == curIns.Locale.ulInstrument+1)
						{
							break;
						}
					}
				}
				else  if( myNoteRequest.tone.instrumentNumber != 0 && myNoteRequest.tone.instrumentNumber > 128)
				{
					long	valeurQT, gmID, valeurBank;
					
					valeurQT = myNoteRequest.tone.instrumentNumber;
					valeurQT = valeurQT >> 7;
				//	DebugLong( valeurQT);
					
					gmID = myNoteRequest.tone.instrumentNumber;
					gmID = gmID & 0x0000007F;
					
					valeurBank = curIns.Locale.ulBank;
					valeurBank = valeurBank & 0x0FFFFFFF;
					valeurBank = valeurBank >> 8;
				//	DebugLong( valeurBank);
					
					if( gmID == curIns.Locale.ulInstrument+1)
					{
						if( valeurQT == valeurBank)
						{
							break;
						}
					}
				}
				else
				{
					if( curIns.Locale.ulInstrument+1 == myNoteRequest.tone.instrumentNumber) break;
				}
			}
			
			if( i < tot)	// did we find it?
			{
				iErr = FindAtomById( sat, &insAt, true, 'ins ', i);
				if( iErr) DebugLong( iErr);
				
				iErr = FindAtomById( insAt, &insHe, true, 'insh', 0);
				if( iErr) DebugLong( iErr);
				
				iErr = GetAtomData( insHe, &curIns, sizeof( curIns));
				if( iErr) DebugLong( iErr);
				
				curIns.cRegions = longswap( curIns.cRegions);
				curIns.Locale.ulBank = longswap( curIns.Locale.ulBank);
				curIns.Locale.ulInstrument = longswap( curIns.Locale.ulInstrument);
				
			/*	iErr = FindAtomById( insAt, &InfoAt, true, 'INFO', 0);
				if( iErr) DebugLong( iErr);
				
				iErr = FindAtomById( InfoAt, &InfoData, true, 'INAM', 0);
				if( iErr) DebugLong( iErr);
				
				iErr = GetAtomData( InfoData, insName, sizeof( insName));
				if( iErr) DebugLong( iErr);*/
				
				for( x = 0; x < 32 && x < myNoteRequest.tone.instrumentName[0]; x++) inst->name[ x]	= myNoteRequest.tone.instrumentName[ x+1]; //insName[ x];
				
				iErr = FindAtomById( insAt, &sat, true, 'lrgn', 0);
				if( iErr) DebugLong( iErr);
				
				for( x = 0; x < curIns.cRegions; x++)
				{
					iErr = FindAtomById( sat, &rgnAt, true, 'rgn ', x);
					if( iErr) DebugLong( iErr);
					
					// Key range
					RGNHEADER 	rgnh;
					iErr = GetAtomDataById( rgnAt, 'rgnh', &rgnh, sizeof( rgnh));
					if( iErr) DebugLong( iErr);
					
					rgnh.RangeKey.usLow = shrtswap( rgnh.RangeKey.usLow);
					rgnh.RangeKey.usHigh = shrtswap( rgnh.RangeKey.usHigh);
					rgnh.RangeVelocity.usLow = shrtswap( rgnh.RangeVelocity.usLow);
					rgnh.RangeVelocity.usHigh = shrtswap( rgnh.RangeVelocity.usHigh);
					rgnh.fusOptions = shrtswap( rgnh.fusOptions);
					rgnh.usKeyGroup = shrtswap( rgnh.usKeyGroup);
					
					// Wave sample
					WSMPL 		wsmp;
					WLOOP		loop;
					iErr = GetAtomDataById( rgnAt, 'wsmp', &wsmp, sizeof( wsmp));
					if( iErr) DebugLong( iErr);
					
					wsmp.cbSize = longswap( wsmp.cbSize);
					wsmp.usUnityNote = shrtswap( wsmp.usUnityNote);
					wsmp.sFineTune = shrtswap( wsmp.sFineTune);
					wsmp.lAttenuation = longswap( wsmp.lAttenuation);
					wsmp.fulOptions = longswap( wsmp.fulOptions);
					wsmp.cSampleLoops = longswap( wsmp.cSampleLoops);
					if( wsmp.cSampleLoops > 0)
					{
						long loopSize = sizeof( loop);
						iErr = FSRead( rgnAt.ref, &loopSize, &loop);
						
						loop.cbSize = longswap( loop.cbSize);
						loop.ulType = longswap( loop.ulType);
						loop.ulStart = longswap( loop.ulStart);
						loop.ulLength = longswap( loop.ulLength);
					}
					else
					{
						loop.cbSize = 0;
						loop.ulType = 0;
						loop.ulStart = 0;
						loop.ulLength = 0;
					}
					
					// Wave Data ID
					WAVELINK	wlnk;
					iErr = GetAtomDataById( rgnAt, 'wlnk', &wlnk, sizeof( wlnk));
					if( iErr) DebugLong( iErr);
					
					wlnk.fusOptions = shrtswap( wlnk.fusOptions);
					wlnk.usPhaseGroup = shrtswap( wlnk.usPhaseGroup);
					wlnk.ulChannel = longswap( wlnk.ulChannel);
					wlnk.ulTableIndex = longswap( wlnk.ulTableIndex);
					
					
					// Load Wave Data
					MyAtom wvpl, wave;
					
					iErr = FindAtomById( at, &wvpl, true, 'wvpl', 0);
					if( iErr) DebugLong( iErr);
					
					iErr = FindAtomById( wvpl, &wave, true, 'wave', wlnk.ulTableIndex);
					if( iErr) DebugLong( iErr);
					
					// FMT
					WAVEFORMAT	fmt;
					iErr = GetAtomDataById( wave, 'fmt ', &fmt, sizeof( fmt));
					if( iErr) DebugLong( iErr);
					
					fmt.wFormatTag = shrtswap( fmt.wFormatTag);
					fmt.nCannels = shrtswap( fmt.nCannels);
					fmt.nSamplesPerSec = longswap( fmt.nSamplesPerSec);
					fmt.nAvgBytesPerSec = longswap( fmt.nAvgBytesPerSec);
					fmt.nBlockAlign = shrtswap( fmt.nBlockAlign);
					fmt.wBitsPerSample = shrtswap( fmt.wBitsPerSample);
					
					// Wave Data
					MyAtom dataAt;
					iErr = FindAtomById( wave, &dataAt, true, 'data', 0);
					if( iErr) DebugLong( iErr);
					
					data = NewPtr( dataAt.size);
					if( data == 0L) DebugLong( -1);
					iErr = GetAtomDataById( wave, 'data', data, dataAt.size);
					if( iErr) DebugLong( iErr);
					
					
					// ************************
					// * Add it to instrument *
					// ************************
					
					for( ii = rgnh.RangeKey.usLow - 12; ii <= rgnh.RangeKey.usHigh - 12; ii++)
					{
						if( ii < NUMBER_NOTES && ii > 0) inst->what[ ii] = inst->numSamples;
					}
					
					if( curMusic != 0L) curData = MADCreateSample( curMusic, ins, inst->numSamples);
					else
					{
						curData = (sData*) NewPtrClear( sizeof( sData));
						if( curData == 0L) MyDebugStr( __LINE__, __FILE__, "");
						sample[ ins * MAXSAMPLE + inst->numSamples] = curData;
						
						inst->numSamples++;
					}
					
					curData->size		= 0L;
					curData->loopBeg	= 0L;
					curData->loopSize	= 0L;
					curData->vol		= MAX_VOLUME;
					curData->c2spd		= NOFINETUNE;
					curData->loopType	= eClassicLoop;
					curData->amp		= 8;
					curData->relNote	= 48 - wsmp.usUnityNote;// + wsmp.sFineTune;	//(60 - ) - 
					// curData->name
						
					curData->data = NewPtr( dataAt.size);
				
					if( curData->data == 0L)
					{
						Erreur( 63, -2);
						
						curData->size = 0L;
					}
					else
					{
						if( dataAt.size)
						{
							BlockMoveData( data, curData->data, dataAt.size);
						}
						
						DisposePtr( data);
						
						switch( fmt.wBitsPerSample)
						{
							case 8:
								ConvertInstrumentIn( (Byte*) curData->data, dataAt.size);
							break;
							
							case 16:
								ConvertInstrumentIn16( (short*) curData->data, dataAt.size);
							break;
						}
						
						curData->size 		= dataAt.size;
						curData->loopBeg 	= loop.ulStart;
						curData->loopSize 	= loop.ulLength;
						curData->vol 		= 64;
						curData->amp	 	= fmt.wBitsPerSample;
						
						if( fmt.nCannels == 2)
						{
							curData->stereo = true;
						}
						if( fmt.nCannels > 2) MyDebugStr( __LINE__, __FILE__, "More than 2 channels");
						
						// **
						curData->c2spd		= fmt.nSamplesPerSec;
					//	curData->relNote	= 0;
						// **
						
						OctavesMIDIName( rgnh.RangeKey.usLow - 12, aStr);
						pStrcat( aStr, "\p -> ");
						OctavesMIDIName( rgnh.RangeKey.usHigh - 12, bStr);
						pStrcat( aStr, bStr);
						pStrcat( aStr, "\p, ");
						NumToString( curData->c2spd, bStr);
						pStrcat( aStr, bStr);
						pStrcat( aStr, "\p Hz");
						
						SetSampNameM( aStr, curData->name);
					}
				}
			}
			
			FSClose( iFileRef);
		}
	}
	
	BAIL:
	
	return;
}

void TESTNEWSYSTEM()
{
	short 						synthCount, no, ii, i;
	OSErr 						thisError;
	NoteAllocator 				na;
	NoteChannel					nc;
	Handle						result;
	OSType						synthType;
	Str31						synthName;
	AtomicInstrument			ai;
	SynthesizerDescription		sd;
	MusicComponent 				mc;

	Str255						aStr, bStr;
	
	sData						*curData;
	long						size, inOutBytes;
	InstSampleDescRec			*sdesc;
	Ptr							data;
	QTAtom						myKeyRangeInfoAtom = 0;
	QTAtom						mySampleInfoAtom = 0;
	QTAtom						mySampleDescAtom = 0;
	QTAtom						mySampleDataAtom = 0;
	QTAtom						myInstInfoAtom = 0;
	QTAtom						myToneDescAtom = 0;
	QTAtom						myInstrumentRefAtom = 0;
	QTAtomID					atomID;
	
	short						ins, samp, x;
	
	sData						**sample;
	InstrData					*inst;
	
	short						sampleIDMap[ 500];
	
	for( i = 0; i < 500; i++) sampleIDMap[ i] = -1;
	
	if( !GetIns( &ins, &samp))
	{
		Erreur( 13, ins);
		return;
	}
	
	na = OpenDefaultComponent(kNoteAllocatorComponentType,0);

	synthCount = NAGetRegisteredMusicDevice( na, 0, nil, nil, nil, nil);

	while( synthCount)
	{
		thisError = NAGetRegisteredMusicDevice(na,synthCount, &synthType, synthName, nil, &mc);
		
		if(!synthName[0])
		{
			SynthesizerDescription sd;

			MusicGetDescription( mc, &sd);
			BlockMove( sd.name, synthName, sd.name[0]+1);
		}
		
		if( synthType == kSoftSynthComponentSubType) goto PROCESS;
		
		synthCount--;
	}
	
	goto BAIL;
	
	PROCESS:
	
	// fill out a note request, using NAStuffToneDescription
	myNoteRequest.info.flags = 0;
	myNoteRequest.info.reserved = 0;
	*(short *)(&myNoteRequest.info.polyphony) = EndianS16_NtoB(2);				// simultaneous tones
	*(Fixed *)(&myNoteRequest.info.typicalPolyphony) = EndianU32_NtoB(0x00010000);
	
	thisError = NAStuffToneDescription( na, myNoteRequest.tone.instrumentNumber, &myNoteRequest.tone);
	if (thisError != noErr) MyDebugStr(__LINE__, __FILE__, "NAStuff");
	
	myNoteRequest.tone.synthesizerType = synthType;
	pStrcpy( myNoteRequest.tone.synthesizerName, synthName);
	
	// display the instrument picker dialog box to elicit an instrument from the user
	thisError = NAPickInstrument( na, 0L, "\pPick an instrument:", &myNoteRequest.tone, kPickSameSynth + kPickUserInsts + kPickDontMix, 0, 0, 0);
	if (thisError != noErr) goto BAIL;
	
	SaveUndo( USample, ins, "\pUndo 'Create MIDI instrument'");
	
	sample = curMusic->sample;
	inst = &curMusic->fid[ ins];
	
	for( i = 0; i < inst->numSamples; i++)
	{
		if( sample[ inst->firstSample + i] != 0L)
		{
			if( sample[ inst->firstSample + i]->data != 0L)
			{
				DisposePtr( (Ptr) sample[ inst->firstSample + i]->data);
				sample[ inst->firstSample + i]->data = 0L;
			}
			DisposePtr( (Ptr) sample[ inst->firstSample + i]);
			sample[ inst->firstSample + i] = 0L;
		}
	}
	
	for( i = 0; i < 32; i++) inst->name[ i]	= 0;
	inst->type			= 0;
	inst->numSamples	= 0;
	
	/**/
	
	for( i = 0; i < 96; i++) inst->what[ i]		= 0;
	for( i = 0; i < 12; i++)
	{
		inst->volEnv[ i].pos		= 0;
		inst->volEnv[ i].val		= 0;
	}
	for( i = 0; i < 12; i++)
	{
		inst->pannEnv[ i].pos	= 0;
		inst->pannEnv[ i].val	= 0;
	}
	inst->volSize		= 0;
	inst->pannSize		= 0;
	
	inst->volSus		= 0;
	inst->volBeg		= 0;
	inst->volEnd		= 0;
	
	inst->pannSus		= 0;
	inst->pannBeg		= 0;
	inst->pannEnd		= 0;

	inst->volType		= 0;
	inst->pannType		= 0;
	
	inst->volFade		= 900;
	inst->vibDepth		= 0;
	inst->vibRate		= 0;

	/***************/
	
	thisError = MusicSetPartInstrumentNumber(mc, 1, myNoteRequest.tone.instrumentNumber);
	if( thisError) goto BAIL;
	
	thisError = MusicGetPartAtomicInstrument(mc, 1, &ai, 0);
	if( thisError) goto BAIL;
	
/*	thisError = NANewNoteChannel( na, &myNoteRequest, &nc);
	if( thisError) Debugger();
	
	thisError = NAPickEditInstrument( na, 0L, "\pTest", 0, nc, ai, 0);
	if( thisError) Debugger();
	
	NADisposeNoteChannel( na, nc);*/
	
/*	QTAtomType Atomtype = 0;
	do
	{
		Atomtype = QTGetNextChildType( ai, kParentAtomIsContainer, Atomtype);
		
		Debugger();
	}
	while( Atomtype != 0);
*/	
	
	for( i = 0; i < QTCountChildrenOfType( ai, kParentAtomIsContainer, kaiKeyRangeInfoType); i++)
	{
		myKeyRangeInfoAtom = QTFindChildByIndex( ai, kParentAtomIsContainer, kaiKeyRangeInfoType, i+1, &atomID);
		
	//	no = QTCountChildrenOfType( ai, myKeyRangeInfoAtom, kaiSampleDescType);
	//	if( no != 1) Debugger();
		
		QTLockContainer( ai);
		
		mySampleDescAtom = QTFindChildByIndex( ai, myKeyRangeInfoAtom, kaiSampleDescType, 1, &atomID);
		
		size = 0;
		thisError = QTGetAtomDataPtr(ai,mySampleDescAtom, &size, (Ptr*)&sdesc);
		if( thisError) goto BAIL;
		
		if( sampleIDMap[ sdesc->sampleDataID] != -1)
		{
			for( ii = sdesc->pitchLow - 12; ii <= sdesc->pitchHigh - 12; ii++)
			{
				if( ii < NUMBER_NOTES && ii > 0) inst->what[ ii] = sampleIDMap[ sdesc->sampleDataID];
			}
		}
		else
		{
			sampleIDMap[ sdesc->sampleDataID] = inst->numSamples;
			
			for( ii = sdesc->pitchLow - 12; ii <= sdesc->pitchHigh - 12; ii++)
			{
				if( ii < NUMBER_NOTES && ii > 0) inst->what[ ii] = inst->numSamples;
			}
			
			// TEST AVANT L'INSTRUMENT REF
			
		/*	no = QTCountChildrenOfType( ai, kParentAtomIsContainer, kaiInstrumentRefType);
			if( no != 0)
			{
				DebugStr("\pInstrument Ref Present");
				myInstrumentRefAtom = QTFindChildByIndex( ai, kParentAtomIsContainer, kaiInstrumentRefType, 1, &atomID);
				
				no = QTCountChildrenOfType( ai, myInstrumentRefAtom, kaiToneDescType);
				if( no != 1) Debugger();
				
				myToneDescAtom = QTFindChildByIndex( ai, myInstrumentRefAtom, kaiToneDescType, 1, &atomID);
				if( myToneDescAtom == 0) Debugger();
			}*/
			
		//	no = QTCountChildrenOfType( ai, kParentAtomIsContainer, kaiSampleInfoType);
		//	if( i == 0) baseNo = sdesc->sampleDataID;
		//	else no = sdesc->sampleDataID;
			
			SetInstruNameM( ins, myNoteRequest.tone.instrumentName, myNoteRequest.tone.instrumentNumber, inst->name);
			
			mySampleInfoAtom = QTFindChildByID( ai, kParentAtomIsContainer, kaiSampleInfoType, sdesc->sampleDataID, &no);	//
			if( mySampleInfoAtom != 0)
			{
				no = QTCountChildrenOfType( ai, mySampleInfoAtom, kaiSampleDataType);
				if( no != 1) MyDebugStr(__LINE__, __FILE__, "kaiSampleDataType");
				
				mySampleDataAtom = QTFindChildByIndex( ai, mySampleInfoAtom, kaiSampleDataType, 1, &atomID);
				if( mySampleDataAtom == 0) MyDebugStr(__LINE__, __FILE__, "kaiSampleDataType");
				
				size = 0L;
				thisError = QTGetAtomDataPtr( ai, mySampleDataAtom, &size, &data);
				if( thisError) MyDebugStr(__LINE__, __FILE__, "QTGetAtomDataPtr");
				
				inOutBytes = (sdesc->sampleSize * sdesc->numSamples) / 8L;
				
			//	if( size != inOutBytes) Debugger();
				
				// ************************
				// * Add it to instrument *
				// ************************
				
				{
					if( curMusic != 0L) curData = MADCreateSample( curMusic, ins, inst->numSamples);
					else
					{
						curData = (sData*) NewPtrClear( sizeof( sData));
						if( curData == 0L) MyDebugStr( __LINE__, __FILE__, "");
						sample[ ins * MAXSAMPLE + inst->numSamples] = curData;
						
						inst->numSamples++;
					}
					
					curData->size		= 0L;
					curData->loopBeg	= 0L;
					curData->loopSize	= 0L;
					curData->vol		= MAX_VOLUME;
					curData->c2spd		= NOFINETUNE;
					curData->loopType	= eClassicLoop;
					curData->amp		= 8;
					curData->relNote	= 0;
					// curData->name
					
					curData->data = NewPtr( inOutBytes);
					
					if( curData->data == 0L)
					{
						Erreur( 63, -2);
						
						curData->size = 0L;
					}
					else
					{
						if( inOutBytes)
						{
							BlockMoveData( data, curData->data, inOutBytes);
						}
						
						if( sdesc->dataFormat == 'raw ')
						{
							switch( sdesc->sampleSize)
							{
								case 8:
									ConvertInstrumentIn( (Byte*) curData->data, inOutBytes);
								break;
								
								case 16:
									ConvertInstrumentIn16( (short*) curData->data, inOutBytes);
								break;
							}
						}
						
						curData->size 		= inOutBytes;
						curData->loopBeg 	= sdesc->loopStart;
						curData->loopSize 	= sdesc->loopEnd - sdesc->loopStart;
						curData->vol 		= 64;
						curData->amp	 	= sdesc->sampleSize;
						
						if( sdesc->numChannels == 2)
						{
							curData->stereo = true;
						}
						if( sdesc->numChannels > 2) MyDebugStr( __LINE__, __FILE__, "More than 2 channels");
						
						// **
						curData->c2spd		= sdesc->sampleRate >> 16;
						curData->relNote	= 60 - sdesc->pitchNormal;
						// **
						
						OctavesMIDIName( sdesc->pitchLow - 12, aStr);
						pStrcat( aStr, "\p -> ");
						OctavesMIDIName( sdesc->pitchHigh - 12, bStr);
						pStrcat( aStr, bStr);
						pStrcat( aStr, "\p, ");
						NumToString( curData->c2spd, bStr);
						pStrcat( aStr, bStr);
						pStrcat( aStr, "\p Hz");
						
						SetSampNameM( aStr, curData->name);
					}
				}
			}
		}
		QTUnlockContainer( ai);
	}
	
	BAIL:
	
	CloseComponent( na);
	
	CreateInstruList();
	DrawInfoInstrument();
	UpdateSampleWindows();
	UpdateInstruMenu();
	UpdateALLWindow();
}

void Quicktime2Converter(void)
{
	DialogPtr				aDialog;
	short					itemHit, itemType, i;
	char					cstr[ 200];
	Str255					aStr, str;
	Rect					tempRect, itemRect;
	Point					myPt;
	Handle					itemHandle;
	long					mresult;
	short					ins, samp, x;
	
	short					CategoryID;
	short					QKInstruID;
	MenuHandle				CategoryMenu;
	
	InstrData				*inst;
	Handle					instCopy;
	
	
	if( QK50) Quicktime5();
	else TESTNEWSYSTEM();
	return;
	
	//SetCursor( GetQDGlobalsArrow( &qdarrow));
	
	if( !GetIns( &ins, &samp))
	{
		Erreur( 13, ins);
		return;
	}
	
	SaveUndo( USample, ins, "\pUndo 'Create MIDI instrument'");
	
	for( i = 0; i < 18; i++) QKInstruMenu[ i] = 0L;
	
	if( CreateNameListQuicktime() != noErr) return;
	
	aDialog = GetNewDialog( 176, 0L, (WindowPtr) -1L);
	SetPortDialogPort( aDialog);
	AutoPosition( aDialog);
	ChangeDialogFont( aDialog);
	ShowWindow( GetDialogWindow( aDialog));
	
	pStrcpy( str, "\pQuicktime version ");
	NumToString( vers1, aStr);	pStrcat( str, aStr);		pStrcat( str, "\p.");
	NumToString( vers2, aStr);	pStrcat( str, aStr);
	
	SetDText( aDialog, 21, str);
	
	GetDialogItem( aDialog, 13, &itemType, &itemHandle, &tempRect);
	NInitSmallPiano( tempRect, SPianoRect);

	CategoryMenu = GetMenu( 152);
	for( i = 1; i <= 16; i++)
	{
		if( CountMenuItems( QKInstruMenu[ i]) < 1)
		{
			DisableMenuItem( CategoryMenu, i);
		}
	}
	
	/*****/

	CategoryID = 1;
	GetItem( CategoryMenu, CategoryID, aStr);
	SetDText( aDialog, 7, aStr);	
	
	QKInstruID = 1;
	GetItem( QKInstruMenu[ CategoryID], QKInstruID, aStr);
	SetDText( aDialog, 8, aStr);
	
	/****************************/
	/* SAVE PREVIOUS INSTRUMENT */
	/****************************/
	{
		long inOutCount;
	
		inOutCount = sizeof( InstrData);
		for( x = 0; x < curMusic->fid[ ins].numSamples; x++)
		{
			sData	*curData = curMusic->sample[ curMusic->fid[ ins].firstSample +  x];
			
			inOutCount += sizeof( sData);
			inOutCount += curData->size;
		}
		
		instCopy = MyNewHandle( inOutCount);
		HLock( instCopy);
		
		BlockMoveData( &curMusic->fid[ ins], *instCopy, sizeof( InstrData));
		inOutCount = sizeof( InstrData);
		
		for( x = 0; x < curMusic->fid[ ins].numSamples; x++)
		{
			sData	*curData;
			
			curData = curMusic->sample[ curMusic->fid[ ins].firstSample +  x];
			
			BlockMoveData( curData, (*instCopy) + inOutCount, sizeof( sData));
			inOutCount += sizeof( sData);
			
			BlockMoveData( curData->data, (*instCopy) + inOutCount, curData->size);
			inOutCount += curData->size;
		}
	}
	/****************************/
	/****************************/
	/****************************/
	
	inst = &curMusic->fid[ ins];
	
	MADPurgeTrackIfInstru( MADDriver, ins);
	ComputeQuicktimeSound( QKInstruSndID[ CategoryID][ QKInstruID], curMusic->sample, &curMusic->fid[ ins], ins);
	CreateInstruList();		DrawInfoInstrument();
	UpdateSampleWindows();	UpdateInstruMenu();
	
	ComputeInstSize( aStr, inst, ins);		SetDText( aDialog, 14, aStr);
	NumToString( QKInstruSndID[ CategoryID][ QKInstruID], aStr);		SetDText( aDialog, 17, aStr);
	/*****/
	
	curSPos = 42;
	str[ 0] = 3;
	str[ 1] = ENote[ curSPos][ 0];
	str[ 2] = ENote[ curSPos][ 1];
	str[ 3] = ENote[ curSPos][ 2];
	SetDText( aDialog, 10, str);
	
	REGODIA:

	do
	{
		//ModalDialog( MyDlgFilterDesc, &itemHit);
		MyModalDialog( aDialog, &itemHit);
		
		switch( itemHit)
		{
			case 13:
				PressSmallPianoQ( aDialog, inst, ins);
			break;

			case 5:	// Category menu
				InsertMenu( CategoryMenu, hierMenu );
				GetDialogItem( aDialog, itemHit, &itemType, &itemHandle, &tempRect);
				
				myPt.v = tempRect.top;	myPt.h = tempRect.left;
				LocalToGlobal( &myPt);
				
				SetItemMark( CategoryMenu, CategoryID, 0xa5);
				
				mresult = PopUpMenuSelect(	CategoryMenu,
											myPt.v,
											myPt.h,
											CategoryID);
				
				SetItemMark( CategoryMenu, CategoryID, 0);
				
				if ( HiWord(mresult ) != 0 )
				{
					CategoryID = LoWord( mresult);
					
					GetItem( CategoryMenu, CategoryID, aStr);
					SetDText( aDialog, 7, aStr);
					
					QKInstruID = 1;
					GetItem( QKInstruMenu[ CategoryID], QKInstruID, aStr);
					SetDText( aDialog, 8, aStr);
					
					MADPurgeTrackIfInstru( MADDriver, ins);
					ComputeQuicktimeSound( QKInstruSndID[ CategoryID][ QKInstruID], curMusic->sample, &curMusic->fid[ ins], ins);
					CreateInstruList();		DrawInfoInstrument();
					UpdateSampleWindows();	UpdateInstruMenu();

					ComputeInstSize( aStr, inst, ins);		SetDText( aDialog, 14, aStr);
					NumToString( QKInstruSndID[ CategoryID][ QKInstruID], aStr);		SetDText( aDialog, 17, aStr);
				}
				DeleteMenu( GetMenuID( CategoryMenu));
			break;
			
			case 6:	// Instruments menu
				InsertMenu( QKInstruMenu[ CategoryID], hierMenu );
				GetDialogItem( aDialog, itemHit, &itemType, &itemHandle, &tempRect);
				
				myPt.v = tempRect.top;	myPt.h = tempRect.left;
				LocalToGlobal( &myPt);
				
				SetItemMark( QKInstruMenu[ CategoryID], QKInstruID, 0xa5);
				
				mresult = PopUpMenuSelect(	QKInstruMenu[ CategoryID],
											myPt.v,
											myPt.h,
											QKInstruID);
				
				SetItemMark( QKInstruMenu[ CategoryID], QKInstruID, 0);
				
				if ( HiWord(mresult ) != 0 )
				{
					QKInstruID = LoWord( mresult);
					
					GetItem( QKInstruMenu[ CategoryID], QKInstruID, aStr);
					SetDText( aDialog, 8, aStr);
					
					MADPurgeTrackIfInstru( MADDriver, ins);
					ComputeQuicktimeSound( QKInstruSndID[ CategoryID][ QKInstruID], curMusic->sample, &curMusic->fid[ ins], ins);
					CreateInstruList();		DrawInfoInstrument();
					UpdateSampleWindows();	UpdateInstruMenu();

					ComputeInstSize( aStr, inst, ins);		SetDText( aDialog, 14, aStr);
					NumToString( QKInstruSndID[ CategoryID][ QKInstruID], aStr);		SetDText( aDialog, 17, aStr);
				}
				DeleteMenu( GetMenuID( QKInstruMenu[ CategoryID]));
			break;
			
			case 11:	// Note menu
				InsertMenu( NoteMenu, hierMenu );
				GetDialogItem( aDialog, itemHit, &itemType, &itemHandle, &tempRect);
				
				myPt.v = tempRect.top;	myPt.h = tempRect.left;
				LocalToGlobal( &myPt);
				
				SetItemMark( NoteMenu, curSPos+1, 0xa5);
				
				mresult = PopUpMenuSelect(	NoteMenu,
											myPt.v,
											myPt.h,
											curSPos+1);
				
				SetItemMark( NoteMenu, curSPos+1, 0);
				
				if ( HiWord(mresult ) != 0 )
				{
					curSPos = LoWord( mresult) - 1;
					
					GetNoteString( curSPos, aStr);
					SetDText( aDialog, 10, aStr);
					
					NDoPlayInstru( curSPos, ins, 0, 0, 0xFF);
					MADDriver->chan[ LastCanal].KeyOn = false;
					
					GetDialogItem( aDialog, 13, &itemType, &itemHandle, &tempRect);
					InvalWindowRect( GetDialogWindow( aDialog), &tempRect);
				}
				DeleteMenu( GetMenuID( NoteMenu));
			break;
		}
		
	}while( itemHit != 1 && itemHit != 2);
	
	if( itemHit == 1)
	{
		
	}
	else
	{
		/*******************************/
		/* RESTORE PREVIOUS INSTRUMENT */
		/*******************************/
		
		long	inOutCount;
		short	x, temp;
		
		MADPurgeTrackIfInstru( MADDriver, ins);
		
		MADKillInstrument( curMusic, ins);
		
		BlockMoveData( *instCopy, &curMusic->fid[ ins], sizeof( InstrData));
		inOutCount = sizeof( InstrData);
		
		temp = curMusic->fid[ ins].numSamples;
		
		curMusic->fid[ ins].numSamples = 0;
		
		for( x = 0; x < temp; x++)
		{
			sData	*curData;
			
			if( curMusic != 0L)
			{
				curData = MADCreateSample( curMusic, ins, x);
			}
			else
			{
				curData = (sData*) NewPtrClear( sizeof( sData));
			}
			
			BlockMoveData( (*instCopy) + inOutCount, curData, sizeof( sData));
			inOutCount += sizeof( sData);
			
			curData->data = MyNewPtr( curData->size);
			BlockMoveData( (*instCopy) + inOutCount, curData->data, curData->size);
			inOutCount += curData->size;
		}
	}
	
	HUnlock( instCopy);
	DisposeHandle( instCopy);
	
	CreateInstruList();
	DrawInfoInstrument();
	UpdateSampleWindows();
	UpdateInstruMenu();
	
	ENDDialog:
	
	DisposDialog( aDialog);

	DisposeMenu( CategoryMenu);
	for( i = 0; i < 18; i++)
	{
		if( QKInstruMenu[ i] != 0L) DisposeMenu( QKInstruMenu[ i]);
	}
	UpdateALLWindow();
}